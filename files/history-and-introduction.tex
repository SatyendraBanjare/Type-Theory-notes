\chapter{Introduction and History }

In mathematics, logic, and thoretical computer science, a \textit{Type System} is any of a class of formal systems which can serve as alternative standard logic system of sets. We consider every "\textit{object}" has a "type" and all different kinds of operations are restricted to the objects of only a particular type.\\

\textbf{Type Theory} is closely related to and is often served as the basis of modern computer's type systems, which are a \textit{programming language feature} for common bug reduction. Type theory was studied to avoid paradoxes like \underline{Kleene–Rosser paradox , Rossel's Paradox} in a variety of formal logics and to rewrite systems. It describes the correctness of step-by-step working of an abstract model of machine. This along with complexity theory does constitute the system theory for complete functioning of any computational machine.\\

Organized research for the mathematics foundation started at the end of the 19th century and formed a new mathematical discipline called mathematical logic, which strongly links to theoretical computer science. It went through a lot of paradoxical results, until the discoveries stabilized during the 20th century with finally imparting mathematical knowledge with several new aspects and components known as  \textit{set theory, model theory, proof theory, etc.} , whose properties are still an active research field. \textit{Stephan Wolfram} in his book titled \underline{New Kind of Science} explores the computational aspects of machine and tries to focus on the idea that simple systems can actually reason perfectly for complex behaviour of a large systems. Classical examples of simple Cellular Automaton* and Turing-Complete machines have been studied.\\

Type theory in a similar sense argues that complex working can be induced from logic constraints of simpler systems. A small Type system can thus account for type-safe* behaviour of a computer system. Now for better comprehension we use the concept of $(\lambda)$-calculus to combine abstraction of type models. In mathematics, two well-known type theories that can serve as logic foundation for a system are \textit{Alonzo Church's} \textbf{ typed $(\lambda)$-calculus} and \textit{Per Martin-Lof's } \textbf{intuitionistic type theory}. 

\section{$\lambda$-Calculus}

Lambda calculus is a formal system in mathematical logic for expressing computation based on function abstraction and its application using variable binding and substitution. It is an accepted universal model of computation based on reduction and abstraction that can be used to theoretically understand behaviour of Turing machine. It was introduced in 1930s by mathematician Alonzo Church. This deals with constructing lambda terms (variable terms which change according to conditions and boundness) and performing reduction operations on them. Reduction Operations consist of $\alpha  and  \beta $ transformations. The former deals with renaming bound variable's name and second with replacing the bound variable with the argument expression in the body of the abstraction.It follows left associtivity i.e \textit{fgh} is just syntactic sugar (alternate form of represetation ) for \textit{(fg)h}.\\

A working thumb rule for performing reductions :
\[
 \boxed {(\lambda param . output)input \implies output [param := input] \implies result }
\]

Example : \[(\lambda x.xy)z \longrightarrow {}_\beta(xy)[x:=z] \longrightarrow {}_\beta (zy) \longrightarrow zy \]

 
\section{Intuitional Type theory} 

Intuitionistic type theory (also known as constructive type theory, or Martin-Lof type theory) has mathematical constructs  built to follow a one-to-one correspondence with logical connectives. For example, the logical connective called implication ( { A$\implies$ B} ) corresponds to the type of a function ( { A$\to$ B}). This correspondence is called the \textit{Curry $–$ Howard isomorphism}. This basically is an equivalent of unique mapping and existence of inverse as in the theory of sets. Previous type theories also followed this isomorphism, but Martin-Lof's was the first to extend it by introducing \textbf{Dependent types} as a basis of \textit{High Order function dependence on basic functions}.\\

\hfill \break \textbf{Machine Assisted Proving} dates back as early as 1976 when the four color theorem was verified using a computer program. Butterfly Effect's discovery also was possible due to computer simulation of program with given some finite initial states. Most computer-aided proofs to date have been implementations of large \textit{Proofs-By-Case} of a mathematical theorem. It is also called as \textit{Proof-By-Induction}  where child cases are considered first in an attempt to fully prove a theorm. Various attempts have been made in the area of \textit{Artificial Intelligence} research to create smaller, explicit proofs of mathematical theorems using machine reasoning techniques such as \textit{heuristic search}.\\

Such \textbf{Automated Theorem Provers} have found new proofs for known theorems also given a number of new results. Additionally, interactive proof assistants allow mathematicians to develop acceptable human-readable proofs which are then again verified too in a similar procedure.   

\section{Proof Assistants Introduction}

Machine theorem basically involves model checking, which, in the simplest case involves brute-force enumeration of many possible states (although the actual implementation of model checkers requires much robustness for checking every case, and it does not simply reduce to brute force). There are \textit{hybrid} theorem  proving systems which use model checking as an inference rule. There are also programs which were written to prove a particular theorem, with an assumption that if the program finishes with a certain result, then our proposed theorem is true.\\

In computer science and mathematical logic, a \textbf{Proof Assistant or Interactive Theorem Prover} is a software tool to help with the development of formal proofs. This involves interactive editor, or other interface, with which a human can guide the search for proofs. Some steps are reduced by the computer and base cases are enlisted to be proved. We will discuss this part later. \\

\hfill \break In the present Programming Language research, the correctness of \textit{Computer Programs} is proved using similar notions considering some "pre" and "post" cases. This idea can thus be extended to proving correctness of a programing language semantics. \\

Currently the developments in Quantum Computing strongly uses these proof-based programming language mainly because of the completely random behaviour of a \textit{Quantum states} of \underline{Qubits}. All that we have are probablities of 
existence of a given quantum state. Let's say we can we can organize the chaos to some extent by \textit{categorizing} those probabilities in few cases, then later operations and control logics will have to have an inductive transfer of the qubit's states. This is analogus to how we deal with things in Type theory. Therefore developing a strong typed abstract model will benefit quantum computing to a much bigger extent.\\

We will understand the working of proof assistants by firstly revisiting topics in abstract algebra, computer architecture and compiler technology. We will then proceed to introduce the type systems and core elements of type theory in study and finally combine both to reason for correctness of a programming language and a programming stack.\\

I have later introduced concepts of quantum computing followed by the application of type theory in it to put some light on some ongoing active research in that field.\\
